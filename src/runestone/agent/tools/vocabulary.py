"""Vocabulary-related agent tools."""

import logging

from langchain.tools import ToolRuntime
from langchain_core.tools import tool
from pydantic import BaseModel, Field, field_validator

from runestone.agent.tools.context import AgentContext
from runestone.agent.tools.service_providers import provide_vocabulary_service

logger = logging.getLogger(__name__)


class WordPrioritisationItem(BaseModel):
    """Input for a single word to prioritize."""

    word_phrase: str = Field(..., description="The Swedish word or phrase")
    translation: str = Field(..., description="Translation of the word_phrase (concise)")
    example_phrase: str = Field(..., description="Example sentence in Swedish")

    @field_validator("word_phrase", "translation", "example_phrase", mode="before")
    @classmethod
    def decode_unicode_escapes(cls, v: str) -> str:
        """Fix double-escaped unicode characters often generated by LLMs."""
        if isinstance(v, str) and "\\u" in v:
            try:
                # v.encode('utf-8') converts 'f\\u00f6...' to bytes b'f\\u00f6...'
                # .decode('unicode_escape') interprets \\u00f6 as รถ
                return v.encode("utf-8").decode("unicode_escape")
            except Exception:
                return v
        return v


class WordPrioritisationInput(BaseModel):
    """Input for prioritizing words for learning."""

    words: list[WordPrioritisationItem] = Field(..., description="List of words to prioritize")


@tool(args_schema=WordPrioritisationInput)
async def prioritize_words_for_learning(
    words: list[WordPrioritisationItem],
    runtime: ToolRuntime[AgentContext],
) -> str:
    """
    Mark words for priority learning. Use when student uses another language
    to express a word or constantly makes errors writing a word.

    For each word:
    - If deleted: restores it and marks for priority
    - If exists: marks for priority
    - If new: creates it with priority flag

    Args:
        words: List of words to prioritize for learning
        runtime: Tool runtime context

    Returns:
        Confirmation message
    """
    user = runtime.context.user

    processed_count = 0
    errors = []

    # Use fresh service with its own session for concurrency safety
    async with provide_vocabulary_service() as vocab_service:
        for word_item in words:
            try:
                await vocab_service.upsert_priority_word(
                    word_phrase=word_item.word_phrase,
                    translation=word_item.translation,
                    example_phrase=word_item.example_phrase,
                    user_id=user.id,
                )
                logger.info(f"Processed priority word: {word_item.word_phrase}")
                processed_count += 1
            except Exception as e:
                logger.error(f"Failed to process {word_item.word_phrase}: {e}")
                errors.append(f"{word_item.word_phrase}: {str(e)}")

    if errors:
        error_msg = "; ".join(errors)
        return f"Processed {processed_count} word(s). Errors: {error_msg}"

    return f"Successfully processed {processed_count} word(s) for priority learning."
